---
phase: 03-design-to-code
plan: 01
type: execute
---

<objective>
Create the Auto Layout → CSS Flexbox knowledge module — the single most critical design-to-code mapping that every generated component depends on.

Purpose: Encode the production plugin's proven layout mapping rules so Claude can correctly interpret Figma Auto Layout frames and generate pixel-accurate CSS Flexbox. This is the foundation all other design-to-code modules build upon.
Output: `knowledge/design-to-code-layout.md`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/2-figma-api/02-01-SUMMARY.md
@.planning/phases/2-figma-api/02-02-SUMMARY.md

# Figma API references (node structure, Auto Layout properties):
@knowledge/figma-api-rest.md
@knowledge/figma-api-plugin.md
@knowledge/figma-api-variables.md

# Source material — the production plugin's extraction + generation:
# READ THESE FILES to extract the actual mapping rules:
# (reference plugin) src/extraction/layout.ts
# (reference plugin) src/generation/layout.ts
# (reference plugin) src/generation/responsive.ts
# (reference plugin) src/extraction/variants.ts
# (reference plugin) src/types/extracted.ts

# Archive specs for additional patterns:
@archive/agent-rewritten-01.md
@archive/initial-agent-audit.md

# Module conventions:
@knowledge/README.md

**Module structure convention:**
1. Title — Clear module name
2. Purpose — What knowledge this module contains
3. When to Use — Scenarios where this module should be @referenced
4. Content — The knowledge itself (rules, mappings, patterns, examples)
5. Cross-References — Related modules to consult

**Tech stack available:** Markdown knowledge files (no code execution)
**Established patterns:** ~700-900 line knowledge modules, TypeScript interfaces where helpful, practical examples
**Constraining decisions:**
- Phase 1: Module structure is title → purpose → when-to-use → content → cross-references
- Phase 2: Node structure, Auto Layout properties documented in figma-api-rest.md and figma-api-plugin.md
- Variables API variable bindings (boundVariables) documented in figma-api-variables.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Read production plugin layout source files</name>
  <files>
    (reference plugin) src/extraction/layout.ts,
    (reference plugin) src/generation/layout.ts,
    (reference plugin) src/generation/responsive.ts,
    (reference plugin) src/extraction/variants.ts,
    (reference plugin) src/types/extracted.ts,
    (reference plugin) src/generation/position.ts
  </files>
  <action>
Read ALL listed source files from the production plugin codebase to understand the complete layout extraction and generation pipeline. Take notes on:

1. **Extraction rules** (layout.ts extraction): How Figma Auto Layout properties are extracted into intermediate types
   - `layoutMode` (HORIZONTAL/VERTICAL/NONE) → internal mode representation
   - `primaryAxisAlignItems` / `counterAxisAlignItems` → alignment extraction
   - `layoutWrap` → wrap mode extraction
   - Padding extraction (top/right/bottom/left, variable bindings)
   - Gap extraction (itemSpacing, counterAxisSpacing, variable bindings)
   - Sizing modes: `layoutSizingHorizontal` / `layoutSizingVertical` (FIXED/HUG/FILL)
   - Min/max constraints: `minWidth`, `maxWidth`, `minHeight`, `maxHeight`
   - Absolute position children: `layoutPositioning: ABSOLUTE`

2. **Generation rules** (layout.ts generation): How intermediate types become CSS
   - `display: flex`, `flex-direction`, `justify-content`, `align-items`
   - Gap handling with variable references
   - Padding shorthand optimization (uniform vs mixed)
   - Flex child sizing: FILL → `flex-grow: 1; flex-basis: 0`, FIXED → `flex-shrink: 0`, HUG → omitted
   - Min/max constraint CSS
   - Wrap + align-content

3. **Responsive patterns** (responsive.ts): Multi-frame responsive CSS generation
   - Breakpoint detection from frame names/variants
   - Mobile-first approach (smallest frame = base)
   - BEM suffix matching across frames
   - `@media (min-width: ...)` generation

4. **Variant detection** (variants.ts): How responsive properties are identified
   - Property names: Device, Breakpoint, Screen, Viewport, Size
   - Value mapping: mobile/sm/xs→mobile, tablet/md→tablet, desktop/lg/xl→desktop

5. **Type definitions** (extracted.ts): The intermediate data model
   - LayoutProperties interface
   - LayoutChildProperties interface
   - All sizing mode types

6. **Position handling** (position.ts): Non-auto-layout positioning
   - Absolute positioning within Auto Layout parents
   - Constraint-based positioning

Do NOT create any files yet. This is a read-only research task.
  </action>
  <verify>All 6 source files read and mapping rules understood. No files created.</verify>
  <done>Complete understanding of the production plugin's layout extraction → generation pipeline, ready to encode into knowledge module.</done>
</task>

<task type="auto">
  <name>Task 2: Create design-to-code-layout.md knowledge module</name>
  <files>knowledge/design-to-code-layout.md</files>
  <action>
Create the authoritative Auto Layout → CSS Flexbox knowledge module using patterns extracted from the production plugin's code.

**Must cover (organized into clear sections):**

1. **Auto Layout → Flexbox Core Mapping**
   - `layoutMode: HORIZONTAL` → `flex-direction: row`, `VERTICAL` → `flex-direction: column`
   - `primaryAxisAlignItems` → `justify-content` mapping table (MIN→flex-start, CENTER→center, MAX→flex-end, SPACE_BETWEEN→space-between)
   - `counterAxisAlignItems` → `align-items` mapping table (MIN→flex-start, CENTER→center, MAX→flex-end, BASELINE→baseline, STRETCH→stretch — note STRETCH is special, only on counter-axis)
   - When `layoutMode: NONE` → no Auto Layout, use absolute/constraint-based positioning

2. **Sizing Modes (CRITICAL — most common source of bugs)**
   - Three modes: FIXED, HUG, FILL
   - `layoutSizingHorizontal` / `layoutSizingVertical` properties
   - FIXED → explicit `width`/`height` + `flex-shrink: 0` (prevent collapse)
   - HUG → content-based (omit explicit sizing, let flexbox handle it)
   - FILL → `flex-grow: 1; flex-basis: 0` (the `flex-basis: 0` is CRITICAL for equal distribution — without it, content-heavy siblings take more space)
   - How sizing interacts with primary vs counter axis in the parent's flex direction
   - FILL on counter-axis → `align-self: stretch` (or parent `align-items: stretch`)

3. **Gap & Spacing**
   - `itemSpacing` → `gap` (primary axis spacing)
   - `counterAxisSpacing` → CSS `row-gap` or `column-gap` (only applies when `layoutWrap: WRAP`)
   - Padding: `paddingTop/Right/Bottom/Left` → CSS `padding` shorthand optimization
   - Variable bindings: `boundVariables.itemSpacing` → use token variable reference instead of raw value

4. **Wrap Mode**
   - `layoutWrap: WRAP` → `flex-wrap: wrap`
   - When wrapped: `counterAxisAlignContent` → `align-content` (distributes wrapped lines)
   - Counter-axis spacing becomes relevant in wrap mode

5. **Min/Max Constraints**
   - `minWidth`, `maxWidth`, `minHeight`, `maxHeight` → direct CSS equivalents
   - These interact with sizing modes (FILL child with maxWidth prevents over-expansion)
   - Common pattern: FILL vertical + maxHeight to prevent overflow

6. **Absolute Position Children**
   - `layoutPositioning: ABSOLUTE` on a child within Auto Layout parent
   - Generates `position: absolute` with constraint-based offsets
   - Parent gets `position: relative` (implicit in Figma, explicit in CSS)

7. **Non-Auto-Layout Frames (GROUP, legacy FRAME)**
   - GROUP: children use absolute coordinates from `absoluteBoundingBox`
   - FRAME without Auto Layout: children positioned by constraints
   - Constraint mapping: LEFT/RIGHT → left/right, TOP/BOTTOM → top/bottom, CENTER → centered, SCALE → percentage, LEFT_RIGHT → left + right (stretch)

8. **Responsive Multi-Frame Pattern**
   - Creating responsive CSS from multiple Figma frames (one per breakpoint)
   - Frame naming conventions: "[name] - Mobile", "[name] - Desktop", "[name] [mobile]"
   - Mobile-first approach: smallest frame = base CSS, larger frames = `@media (min-width)` overrides
   - Standard breakpoints: mobile (base, <768px), tablet (768-1023px), desktop (≥1024px)
   - BEM suffix matching to align elements across frames
   - Variant component detection: COMPONENT_SET with Device/Breakpoint/Screen/Viewport/Size properties

9. **Common Pitfalls & Edge Cases**
   - `flex-basis: 0` is essential for FILL items — omitting it causes uneven distribution
   - STRETCH alignment only exists on counter-axis (not primary)
   - `itemSpacing` applies between children, NOT as padding
   - GROUP nodes have no layout mode — children need absolute positioning
   - Figma's "Auto" width/height in the UI maps to HUG (not FILL)
   - Mixed sizing: some children FILL while others HUG in the same parent is valid

**Format:** Follow module structure convention. Include complete mapping tables. Use TypeScript interfaces for the extracted intermediate types. Provide CSS generation examples for each mapping rule. Include a "decision tree" for sizing mode → CSS generation.

**Do NOT:** Include real API keys, fabricate Figma properties that don't exist, or document patterns not verified against the production plugin's actual code.
  </action>
  <verify>
    - File exists at knowledge/design-to-code-layout.md
    - Contains all 5 sections (title, purpose, when-to-use, content, cross-references)
    - Documents complete Auto Layout → Flexbox mapping table
    - Covers all 3 sizing modes (FIXED, HUG, FILL) with correct CSS
    - Documents flex-basis: 0 for FILL (critical pattern)
    - Covers gap, padding, wrap, min/max, absolute positioning, constraints
    - Includes responsive multi-frame pattern
    - Cross-references figma-api-rest.md, figma-api-plugin.md, figma-api-variables.md
    - No real API keys or secrets
  </verify>
  <done>design-to-code-layout.md exists with complete Auto Layout → Flexbox reference covering all sizing modes, alignment mapping, spacing, wrapping, constraints, responsive patterns, and common pitfalls. All patterns verified against the production plugin's code.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] knowledge/design-to-code-layout.md exists
- [ ] Follows module structure convention (title, purpose, when-to-use, content, cross-references)
- [ ] All mapping tables are complete and accurate (verified against the production plugin source)
- [ ] Sizing mode decision tree is clear (FIXED/HUG/FILL → CSS)
- [ ] `flex-basis: 0` for FILL items is documented as critical
- [ ] Responsive multi-frame pattern documented
- [ ] Cross-references to Figma API modules included
- [ ] No secrets, no fabricated properties
</verification>

<success_criteria>

- Layout knowledge module created and follows conventions
- All Auto Layout → Flexbox mappings extracted from the production plugin's code
- Sizing modes (FIXED/HUG/FILL) correctly documented with CSS output
- Content optimized for Claude Code @reference consumption
- Cross-references to Phase 2 Figma API modules
</success_criteria>

<output>
After completion, create `.planning/phases/3-design-to-code/03-01-SUMMARY.md`
</output>
