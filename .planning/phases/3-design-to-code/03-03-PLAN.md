---
phase: 03-design-to-code
plan: 03
type: execute
---

<objective>
Create the typography and asset management knowledge modules — encoding the production plugin's rules for text extraction/generation and vector container detection/image handling.

Purpose: Enable Claude to correctly extract Figma text properties and generate accurate CSS typography, AND to detect which nodes should be exported as SVG/PNG assets vs rendered as CSS.
Output: `knowledge/design-to-code-typography.md` and `knowledge/design-to-code-assets.md`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/3-design-to-code/03-01-SUMMARY.md
@.planning/phases/3-design-to-code/03-02-SUMMARY.md

# Figma API references:
@knowledge/figma-api-rest.md
@knowledge/figma-api-variables.md

# Sibling modules:
@knowledge/design-to-code-layout.md
@knowledge/design-to-code-visual.md

# Source material — the production plugin's text + asset handling:
# READ THESE FILES:
# (reference plugin) src/extraction/text.ts
# (reference plugin) src/generation/typography.ts
# (reference plugin) src/extraction/assets.ts
# (reference plugin) src/generation/html.ts (for hyperlink/list extraction)
# (reference plugin) src/tokens/typography.ts
# (reference plugin) src/types/extracted.ts (TextData, AssetData)

# Archive specs:
@archive/agent-rewritten-01.md

# Module conventions:
@knowledge/README.md

**Established patterns:** ~700-900 line knowledge modules
**Constraining decisions:**
- Phase 1: Module structure convention
- Phase 2: REST API image export endpoints documented in figma-api-rest.md
- Phase 2: Plugin API SceneNode types documented in figma-api-plugin.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create design-to-code-typography.md knowledge module</name>
  <files>knowledge/design-to-code-typography.md</files>
  <action>
Read the production plugin's text extraction and typography generation source files, then create the authoritative typography knowledge module.

**Source files to read first:**
- (reference plugin) `src/extraction/text.ts`
- (reference plugin) `src/generation/typography.ts`
- (reference plugin) `src/tokens/typography.ts`
- (reference plugin) `src/types/extracted.ts` (TextData type)

**Must cover:**

1. **Font Family Mapping**
   - Figma `fontFamily` → CSS `font-family` with appropriate fallback stack
   - Common font stacks: system-ui, sans-serif, serif, monospace
   - Token lookup: if a font token exists, use `var(--font-family-name)` instead of raw family
   - Google Fonts / web font considerations (just reference, don't solve loading)

2. **Font Weight from Style String**
   - Figma uses style names: "Regular", "Bold", "Semi Bold", "Light", "Medium", "Extra Bold", "Black", etc.
   - Mapping table: Thin→100, Extra Light→200, Light→300, Regular→400, Medium→500, Semi Bold→600, Bold→700, Extra Bold→800, Black→900
   - Italic detection: style contains "Italic" → `font-style: italic`
   - Combined styles: "Bold Italic" → `font-weight: 700; font-style: italic`
   - Token lookup: `var(--font-weight-bold)` if available

3. **Font Size**
   - `fontSize` → `font-size: Npx`
   - Token lookup: `var(--font-size-lg)` if available
   - Common sizing scale for semantic naming

4. **Line Height Conversion (Critical)**
   - Figma stores line height in multiple formats:
     - Percentage value (e.g., 150%) → CSS unitless ratio: `line-height: 1.5`
     - Pixel value (e.g., 24px on 16px font) → CSS unitless ratio: `line-height: 1.5` (24/16)
     - Auto → omit `line-height` (browser default)
   - **Always convert to unitless ratio** — this scales correctly with font-size changes
   - Formula: `lineHeightPx / fontSize` = unitless ratio

5. **Letter Spacing**
   - Figma `letterSpacing` in pixels → CSS `letter-spacing: Npx`
   - Percentage letter spacing → convert to `em` units
   - Zero or near-zero → omit property

6. **Text Alignment**
   - Horizontal: LEFT→`text-align: left`, CENTER→`center`, RIGHT→`right`, JUSTIFIED→`justify`
   - Vertical alignment: TOP→omit (default), CENTER→`display: flex; align-items: center`, BOTTOM→`display: flex; align-items: flex-end`
   - Vertical alignment requires flex container on the text element

7. **Text Decoration & Transform**
   - `textDecoration: UNDERLINE` → `text-decoration: underline`
   - `textDecoration: STRIKETHROUGH` → `text-decoration: line-through`
   - `textCase: UPPER` → `text-transform: uppercase`
   - `textCase: LOWER` → `text-transform: lowercase`
   - `textCase: TITLE` → `text-transform: capitalize`

8. **Text Auto-Resize Behavior**
   - `textAutoResize: WIDTH_AND_HEIGHT` → `white-space: nowrap` (text doesn't wrap)
   - `textAutoResize: HEIGHT` → width is fixed, height grows (default wrapping behavior)
   - `textAutoResize: NONE` → fixed width AND height (may overflow/clip)
   - `textAutoResize: TRUNCATE` → `overflow: hidden; text-overflow: ellipsis; white-space: nowrap`

9. **Styled Text Segments (Rich Text)**
   - Figma supports per-character styling within a single text node
   - Extract styled segments: each segment has its own font, size, weight, color, decoration
   - CSS generation: wrap segments in `<span>` elements with individual styles
   - Hyperlink segments: `{ type: 'URL', url: '...' }` → wrap in `<a href="...">`

10. **List Styles**
    - Ordered lists: detected from text content patterns or Figma's list metadata
    - Unordered lists: bullet characters or Figma list metadata
    - Generation: `<ol>` / `<ul>` with `<li>` children

11. **Typography Token Integration**
    - Font family tokens, size tokens, weight tokens
    - Semantic naming: "text-base", "text-lg", "text-xl", "font-bold"
    - Token lookup during generation: raw value → `var(--token-name)` if threshold met

12. **Common Pitfalls**
    - Line height as percentage in Figma means % of font size, NOT of the box
    - Font style "Regular" should not output `font-weight: regular` — it's `400`
    - Mixed-style text nodes need segment-level extraction, not node-level
    - Vertical text alignment requires flex container — can conflict with text layout

**Format:** Follow module structure convention. Include complete font weight mapping table. CSS examples for each property.
  </action>
  <verify>
    - File exists at knowledge/design-to-code-typography.md
    - Contains all 5 sections (title, purpose, when-to-use, content, cross-references)
    - Complete font weight mapping table (Thin→100 through Black→900)
    - Line height conversion documented (percentage → unitless ratio)
    - Text auto-resize → CSS behavior mapping complete
    - Styled segments documented
    - Cross-references to API modules and sibling design-to-code modules
    - No real API keys or secrets
  </verify>
  <done>design-to-code-typography.md exists with complete text extraction and CSS typography reference covering fonts, weights, line height, letter spacing, alignment, decoration, auto-resize, styled segments, and token integration.</done>
</task>

<task type="auto">
  <name>Task 2: Create design-to-code-assets.md knowledge module</name>
  <files>knowledge/design-to-code-assets.md</files>
  <action>
Read the production plugin's asset extraction source files, then create the authoritative asset management knowledge module.

**Source files to read first:**
- (reference plugin) `src/extraction/assets.ts`
- (reference plugin) `src/generation/html.ts` (asset rendering patterns)
- (reference plugin) `src/types/extracted.ts` (AssetData type)

**Must cover:**

1. **Vector Container Detection (Critical Heuristic)**
   - Definition: A frame or group whose children are ALL vector-compatible types
   - Vector-compatible types: VECTOR, BOOLEAN_OPERATION, STAR, POLYGON, LINE, ELLIPSE, RECTANGLE
   - If a container has ANY non-vector child (TEXT, FRAME with children, INSTANCE), it is NOT a vector container
   - Vector containers should be exported as SVG, not rendered as CSS
   - Purpose: prevents attempting to render complex icon geometry as CSS divs

2. **CSS-Renderable Shapes vs SVG Export**
   - CSS-renderable: ELLIPSE (→ `border-radius: 50%`), RECTANGLE (→ div with border-radius)
   - SVG export: VECTOR, BOOLEAN_OPERATION, STAR, POLYGON, LINE (complex geometry)
   - Decision tree:
     - Is it a vector container? → Export entire container as SVG
     - Is it a single ELLIPSE/RECTANGLE? → Render as CSS div
     - Is it a single VECTOR/BOOLEAN_OP? → Export as SVG
     - Does it have text children? → Cannot flatten to SVG (text needs to remain selectable)

3. **SVG Export via Figma API**
   - Endpoint: `GET /v1/files/:key/images?ids=NODE_ID&format=svg`
   - Returns URL to generated SVG
   - SVG cleanup: remove unnecessary Figma metadata attributes
   - Inline SVG vs external file considerations

4. **Image Fill Handling**
   - Nodes with IMAGE fills have `imageRef` property
   - Export via: `GET /v1/files/:key/images?ids=NODE_ID&format=png&scale=2` (2x for retina)
   - Image deduplication: same `imageRef` hash → same image, reference once
   - `scaleMode: FILL` → CSS `object-fit: cover`, `scaleMode: FIT` → `object-fit: contain`
   - `scaleMode: CROP` → specific `object-position` based on crop bounds
   - `scaleMode: TILE` → CSS `background-repeat: repeat`

5. **Asset Map & Deduplication**
   - Build `Map<imageHash, { filename, url }>` during extraction
   - Multiple nodes using same image → single asset file referenced multiple times
   - Naming: derive from node name, sanitize for filesystem (lowercase, hyphens, no special chars)
   - Hash-based dedup prevents downloading same image twice

6. **Multi-Factor Detection Heuristics**
   - Sometimes a node looks like it should be an asset but shouldn't:
     - Single RECTANGLE with solid fill → CSS div (not an asset)
     - Group of vectors forming an icon → SVG asset
     - Frame with mixed vector + text children → NOT an asset (has text content)
     - INSTANCE of a vector component → export the instance as SVG
   - Decorative vs functional: simple geometric shapes (circles, rectangles) → CSS; complex shapes → SVG

7. **Export Format Selection**
   - SVG: Vector graphics, icons, logos, illustrations (scalable)
   - PNG: Raster images, photos, complex gradients (use 2x scale for retina)
   - JPG: Photos where file size matters (lossy compression acceptable)
   - PDF: Print-ready assets (rare in web context)
   - Format selection heuristic: vectors → SVG, images → PNG@2x, photos → JPG

8. **Common Pitfalls**
   - Don't export every node as an image — only nodes that can't be CSS-rendered
   - BOOLEAN_OPERATION nodes have `booleanOperation` type (UNION, INTERSECT, SUBTRACT, EXCLUDE) — always SVG
   - Image fills on text nodes: the text has a background image, NOT an image replacement
   - Vector nodes can have fills/strokes — these are SVG attributes, not CSS
   - Retina: always export at 2x minimum for crisp display on modern screens
   - Large SVGs: if a vector container has many children, the SVG can be huge — consider PNG fallback

**Format:** Follow module structure convention. Include the vector container detection decision tree as a flowchart/pseudocode. Asset type decision matrix.
  </action>
  <verify>
    - File exists at knowledge/design-to-code-assets.md
    - Contains all 5 sections (title, purpose, when-to-use, content, cross-references)
    - Vector container detection heuristic is clear and complete
    - CSS-renderable vs SVG export decision tree documented
    - Image fill handling with scaleMode → CSS mapping
    - Asset deduplication strategy documented
    - Export format selection guidance included
    - Cross-references figma-api-rest.md (image export endpoints)
    - No real API keys or secrets
  </verify>
  <done>design-to-code-assets.md exists with complete asset management reference covering vector container detection, CSS vs SVG decision tree, image handling, deduplication, export format selection, and common pitfalls.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] knowledge/design-to-code-typography.md exists
- [ ] knowledge/design-to-code-assets.md exists
- [ ] Both follow module structure convention
- [ ] Typography: complete font weight table, line height conversion, auto-resize mapping, styled segments
- [ ] Assets: vector container detection heuristic, CSS vs SVG decision tree, image dedup
- [ ] Cross-references between all design-to-code modules and API modules
- [ ] No secrets, no fabricated properties
</verification>

<success_criteria>

- Both typography and assets knowledge modules created
- Font weight mapping table complete (Thin→100 through Black→900)
- Line height conversion correctly documented
- Vector container detection heuristic matches the production plugin's logic
- Asset deduplication strategy documented
- Content optimized for Claude Code @reference consumption
</success_criteria>

<output>
After completion, create `.planning/phases/3-design-to-code/03-03-SUMMARY.md`
</output>
