---
phase: 05-payload-integration
plan: 01
type: execute
---

<objective>
Create PayloadCMS block system and Figma-to-PayloadCMS mapping knowledge modules.

Purpose: Document the production block patterns from the reference PayloadCMS project and establish the authoritative Figma component → PayloadCMS block mapping rules that will power the `/figma:map-payload-block` skill.
Output: Two knowledge modules: `knowledge/payload-blocks.md` and `knowledge/payload-figma-mapping.md`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries (PayloadCMS builds on design-to-code + tokens knowledge):
@.planning/phases/03-design-to-code/03-04-SUMMARY.md
@.planning/phases/04-css-tokens/04-02-SUMMARY.md

# Source codebase for PayloadCMS patterns:
# Reference PayloadCMS project
# Key paths to read:
#   - /src/admin/blocks/ (all block configs)
#   - /src/admin/fields/ (field factories: imageTabs, linkGroup, link, className, layoutMeta)
#   - /src/admin/blocks/RenderBlocks.tsx (block rendering registry)
#   - /src/payload.config.ts (Payload config, collections, plugins)
#   - /src/styles/tokens.css (design tokens)
#   - /src/styles/blocks/ (CSS Modules per block)

# Existing knowledge modules for cross-referencing:
@knowledge/figma-api-rest.md
@knowledge/figma-api-variables.md
@knowledge/design-to-code-layout.md
@knowledge/design-to-code-visual.md
@knowledge/design-to-code-semantic.md
@knowledge/css-strategy.md
@knowledge/design-tokens.md
@knowledge/design-tokens-variables.md

**Established patterns:**
- Knowledge module structure: title → purpose → when-to-use → content → cross-refs
- Module naming: `{domain}-{topic}.md`
- Bidirectional cross-references between related modules
- Three-layer CSS: Tailwind (bones) + Custom Properties (tokens) + CSS Modules (skin)
- Container-first architecture mirrors Figma Auto Layout
- Token naming: `--token-{category}-{name}`

**Constraining decisions:**
- Phase 3: BEM flat hierarchy (never block__element__sub)
- Phase 3: Three-layer CSS strategy (Tailwind + Custom Props + Modules)
- Phase 4: Token extraction pipeline (collect → promote → name → render)
- Phase 4: Variable resolution chain (bound ref → resolve aliases → per-mode values → CSS custom property)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PayloadCMS block system knowledge module</name>
  <files>knowledge/payload-blocks.md</files>
  <action>
Create comprehensive PayloadCMS block system reference extracted from the reference PayloadCMS project's production patterns.

**Read these source files first:**
- All block configs (content/, layout/ subdirectories)
- Field factories (imageTabs.ts, linkGroup.ts, link.ts, className/, layoutMeta.ts)
- RenderBlocks.tsx for block rendering patterns
- payload.config.ts for collection/plugin configuration
- CSS Modules for blocks

**Module structure (follow established pattern):**

1. **Purpose & When to Use** — When building PayloadCMS blocks, when mapping Figma components to CMS blocks, when extending block system

2. **Block Architecture Overview** — Block type definition (`Block` from payload), slug naming, field organization, tab pattern (Content/Settings/Media/CTA tabs)

3. **Field Types Reference** — Complete field type catalog used in blocks:
   - richText (Lexical editor with feature configuration)
   - upload (media collection relationship)
   - relationship (document linking)
   - group (nested field groups)
   - array (repeatable items, e.g., accordion items, button groups)
   - select, radio, text, checkbox, number
   - tabs (field organization)

4. **Reusable Field Factories** — Document each factory with signature, purpose, usage:
   - `imageTabs` — standard image upload group
   - `linkGroup()` — factory for CTA/button arrays with internal/external URL toggle
   - `link` — single link with appearance options
   - `className` — custom CSS class text field
   - `layoutMeta` — spacing controls (marginTop/Bottom, paddingTop/Bottom, hidden)

5. **Block Catalog** — Every block with its slug, category, fields structure, and CSS Module:
   - Content blocks: Hero, Card, Button, RichText, Media, Video, Accordion, Stats, Testimonial, CallToAction, StickyCTA, SubNavigation
   - Layout blocks: Container, Carousel, Tabs, Grid
   - Utility blocks: Code, FormEmbed
   - For each: slug, tab structure, key fields, renderer component path, CSS Module

6. **Container Block Deep Dive** — The most important block for Figma mapping:
   - Nesting model (layout.content.blocks path)
   - Layout options: col/row/grid
   - Alignment: alignItems, justifyContent
   - Gap with Tailwind token values
   - Width constraints: full/wide/narrow
   - htmlTag semantic element selection
   - Self-nesting prevention (and why)

7. **Block Rendering** — RenderBlocks component pattern, block type → component registry, CSS Module application per block

8. **Collections Integration** — Pages collection with layout.blocks, Media collection for uploads, relationship patterns

9. **Lexical Editor Configuration** — Feature configuration for rich text, restricted features for specific blocks (e.g., Card uses reduced feature set)

10. **Token Integration** — How blocks consume `--token-*` CSS custom properties, CSS Module `@import '../tokens.css'` pattern, fallback values

11. **Cross-References** — Link to css-strategy.md (three-layer CSS), design-tokens.md (token naming), design-to-code-semantic.md (HTML element selection), payload-figma-mapping.md, payload-visual-builder.md

**Target: ~900-1100 lines. Follow the exact XML/markdown structure used in all prior knowledge modules.**
  </action>
  <verify>
- File exists at knowledge/payload-blocks.md
- Contains all 11 sections listed above
- Block catalog covers all block types from the reference project
- Cross-references to at least 4 existing knowledge modules
- No secrets or API keys
  </verify>
  <done>payload-blocks.md exists with comprehensive block system documentation covering architecture, fields, catalog, container deep-dive, rendering, and token integration</done>
</task>

<task type="auto">
  <name>Task 2: Create Figma-to-PayloadCMS mapping knowledge module</name>
  <files>knowledge/payload-figma-mapping.md</files>
  <action>
Create the Figma component → PayloadCMS block mapping knowledge module. This is the bridge between design-to-code knowledge (Phases 2-4) and the CMS block system (Task 1).

**Module structure:**

1. **Purpose & When to Use** — When converting Figma designs to PayloadCMS page structures, when building Figma importers, when mapping component properties to block fields

2. **Mapping Architecture Overview** — The full pipeline: Figma component → identify block type → map properties to fields → generate block config → render with CSS Modules + tokens

3. **Component-to-Block Type Mapping** — Decision tree for which Figma component becomes which PayloadCMS block:
   - Frame with Auto Layout + children → Container block
   - Frame with hero-like structure (full-width, background image, overlay, CTA) → Hero block
   - Frame with image + text + optional CTA → Card block
   - Text node or text-heavy frame → RichText block
   - Button-like frame (small, CTA text, fill background) → Button block
   - Image/illustration frame → Media block
   - Expandable/collapsible groups → Accordion block
   - Tabbed interface → Tabs block
   - Statistics/metrics layout → Stats block
   - Carousel/slider patterns → Carousel block
   - Provide heuristic rules with confidence scores for each mapping

4. **Property-to-Field Mapping Tables** — For each block type, how Figma properties map to PayloadCMS fields:
   - Auto Layout properties → Container settings (layout, alignItems, justifyContent, gap, width)
   - Text content → richText fields (Lexical format)
   - Image fills → upload fields (media collection)
   - Component variants → block type variants (e.g., Hero highImpact/mediumImpact/lowImpact)
   - Figma component properties (boolean, text, instance swap) → block field values
   - Spacing (padding/margin) → layoutMeta fields
   - Semantic hints (frame names containing "nav", "header", "footer") → htmlTag selection

5. **Container Nesting Rules** — How Figma's nested Auto Layout frames map to PayloadCMS container nesting:
   - Top-level frames → root layout.blocks
   - Nested Auto Layout → nested Container blocks
   - Self-nesting limit (Payload schema constraint)
   - When to flatten vs preserve nesting hierarchy
   - Group detection: when multiple siblings share container

6. **Design Token Bridge** — How Figma design tokens flow into PayloadCMS blocks:
   - Figma color styles/variables → `--token-color-*` in tokens.css
   - Figma spacing values → `--token-spacing-*` in tokens.css
   - Figma text styles → `--token-font-*` + `--token-line-height-*`
   - Figma effects → `--token-shadow-*`
   - Figma corner radius → `--token-radius-*`
   - Gap values → Tailwind token classes (gap-0 through gap-16)
   - Reference design-tokens.md extraction pipeline

7. **Variant Mapping (CVA Pattern)** — How Figma component variants map to block variants:
   - Figma variant properties → PayloadCMS radio/select fields
   - CVA (Class Variance Authority) for React renderers
   - Variant → CSS class mapping in CSS Modules
   - Example: Hero variant (high/medium/low impact) from Figma component set

8. **Instance and Slot Mapping** — How Figma component instances map to block references:
   - Component instances → nested block references
   - Instance overrides → field value overrides
   - Slot pattern (Figma instance swap property → PayloadCMS relationship field)

9. **Rich Text Extraction** — How Figma text nodes become Lexical editor content:
   - Text content extraction from styled segments
   - Bold/italic/underline → Lexical formatting
   - Links within text → Lexical link nodes
   - Heading hierarchy from font size/weight → Lexical heading nodes
   - List patterns (bullet points in Figma) → Lexical list nodes

10. **Media Asset Pipeline** — How Figma images become PayloadCMS media:
    - Image fill extraction (reference design-to-code-assets.md)
    - Export at 2x for retina
    - Upload to Media collection
    - Store relationship in block's upload field
    - SVG handling (inline vs upload decision)

11. **Responsive Considerations** — How Figma responsive variants map to PayloadCMS:
    - Figma responsive frames → Container width settings (full/wide/narrow)
    - Breakpoint-specific layouts → CSS Module media queries
    - Mobile-first token values (reference css-strategy.md responsive approach)

12. **Complete Mapping Example** — Walk through a full page:
    - Figma page with Hero + Container(Cards) + CTA section
    - Show the complete mapping from Figma JSON to PayloadCMS block tree
    - Include field values, token references, and CSS Module application

13. **Cross-References** — Link to payload-blocks.md (block definitions), payload-visual-builder.md (editing), design-to-code-layout.md (Auto Layout rules), design-to-code-visual.md (visual properties), design-to-code-semantic.md (HTML elements), css-strategy.md (CSS layers), design-tokens.md (token pipeline), design-tokens-variables.md (variable resolution)

**Target: ~1000-1200 lines. This module is the crown jewel of Phase 5 — it bridges the design-to-code and CMS worlds.**
  </action>
  <verify>
- File exists at knowledge/payload-figma-mapping.md
- Contains all 13 sections listed above
- Mapping tables cover all major block types
- Complete mapping example walks through realistic scenario
- Cross-references to at least 6 existing knowledge modules
- No secrets or API keys
  </verify>
  <done>payload-figma-mapping.md exists with comprehensive Figma→PayloadCMS mapping rules covering component identification, property mapping, nesting, tokens, variants, rich text, media, and complete example</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both knowledge modules exist and follow established structure
- [ ] payload-blocks.md covers the complete reference project block catalog
- [ ] payload-figma-mapping.md provides actionable mapping rules (not vague guidance)
- [ ] Cross-references are bidirectional where appropriate
- [ ] No TypeScript code examples contain syntax errors
- [ ] No secrets, API keys, or credentials
</verification>

<success_criteria>

- Both knowledge modules created with comprehensive content
- Block system documentation faithful to reference project production code
- Mapping rules specific enough for Claude to execute without clarification
- Cross-references connect to existing design-to-code and CSS strategy modules
- Each module ~900-1200 lines following established conventions
</success_criteria>

<output>
After completion, create `.planning/phases/05-payload-integration/05-01-SUMMARY.md`
</output>
