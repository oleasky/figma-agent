---
phase: 05-payload-integration
plan: 02
type: execute
---

<objective>
Create Visual Builder plugin architecture knowledge module, cross-verify all Phase 5 modules, and update CLAUDE.md.

Purpose: Complete the PayloadCMS knowledge suite with visual builder patterns and ensure all modules are verified and integrated.
Output: `knowledge/payload-visual-builder.md`, cross-verification results, updated CLAUDE.md
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Plan 1 outputs (read these first):
@.planning/phases/05-payload-integration/05-01-SUMMARY.md
@knowledge/payload-blocks.md
@knowledge/payload-figma-mapping.md

# Source codebase for visual builder:
# Reference PayloadCMS project's visual builder package
# Key paths to read:
#   - src/plugin.ts (plugin factory, configuration)
#   - src/client-entry.ts (browser exports)
#   - index.ts (server exports)
#   - src/components/VisualBuilder.tsx (main component)
#   - src/components/Canvas.tsx (drag-drop canvas)
#   - src/components/BlockWrapper.tsx (block chrome)
#   - src/components/Inspector.tsx (property panel)
#   - src/components/BlockLayers.tsx (tree view)
#   - src/components/TabbedSidebar.tsx (sidebar layout)
#   - src/components/editBlocks/ (all edit block components)
#   - src/components/inline/ (EditableText, EditableMedia, InlineLexicalEditor)
#   - src/hooks/ (useSaveQueue, useHistory, useDndHandlers, useBlocksValue, useViewportPreset)
#   - src/utils/containerAdapter.ts (nesting logic)
#   - src/contexts/HistoryContext.tsx (undo/redo)

# Existing knowledge for cross-referencing:
@knowledge/figma-api-plugin.md
@knowledge/design-to-code-layout.md
@knowledge/design-to-code-visual.md
@knowledge/design-to-code-semantic.md
@knowledge/css-strategy.md
@knowledge/design-tokens.md

**Established patterns:**
- Cross-verification: check every module references related modules bidirectionally
- CLAUDE.md update: remove "(coming)" from completed modules
- Knowledge module structure: title → purpose → when-to-use → content → cross-refs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Visual Builder plugin architecture knowledge module</name>
  <files>knowledge/payload-visual-builder.md</files>
  <action>
Create comprehensive visual builder plugin architecture reference from the reference PayloadCMS project's visual builder plugin.

**Read the full plugin source first:**
- Visual builder plugin package
- All component files, hooks, utils, contexts

**Module structure:**

1. **Purpose & When to Use** — When building or extending visual builders for PayloadCMS, when understanding inline editing architecture, when building Figma-to-CMS importers that need visual editing support

2. **Plugin Architecture Overview** — Two-entry pattern:
   - `index.ts` (Node-safe server entry): plugin factory export, configuration types
   - `client-entry.ts` (Browser entry): React components, hooks, utilities, registry
   - Plugin factory pattern: `visualBuilderPlugin({ collections, blocksFieldPath, features })`
   - How Payload plugin system works (collection modification, admin component injection)

3. **Configuration API** — Complete plugin configuration:
   - `collections`: Which collections to enable visual builder on
   - `blocksFieldPath`: Dot-notation path to blocks array (e.g., 'layout.blocks')
   - `features`: Toggle object for inlineEditing, dragAndDrop, inspector, keyboardShortcuts, undoRedo, responsivePreview
   - How configuration flows to components

4. **Core Components** — Architecture of each major component:
   - **VisualBuilder.tsx**: Main component, state management, tabbed sidebar integration, uses `useDocumentInfo()` (NOT form state hooks — critical architectural decision)
   - **Canvas.tsx**: Block rendering canvas, dnd-kit DragOverlay, pointerWithin collision detection, selection/hover state
   - **BlockWrapper.tsx**: Common wrapper providing selection outline, drag handle, hover toolbar, passes props to edit blocks
   - **Inspector.tsx**: Side panel for selected block properties, container layout controls, layoutMeta fields
   - **BlockLayers.tsx**: Hierarchical tree view, expand/collapse, click-to-select, keyboard nav
   - **TabbedSidebar.tsx**: Icon rail with tab switching (Fields/Outline/Blocks)

5. **Edit Block System** — How blocks become visually editable:
   - EditBlockProps interface: block, onChange, isSelected, onSelect, dragHandleProps, onRemove, onMoveUp, onMoveDown, onDuplicate, onEditInPayload
   - Registry pattern: `registerEditBlock(slug, Component)`, `getEditBlock(slug)`
   - Per-block edit components: HeroEdit, ContainerEdit, CardEdit, RichTextEdit, MediaEdit, ButtonEdit, AccordionEdit, VideoEdit, TestimonialEdit
   - Fallback for unregistered blocks

6. **Inline Editing Components** — How content becomes editable in-place:
   - **EditableText.tsx**: contenteditable div, inline formatting, onChange on blur
   - **EditableMedia.tsx**: Clickable image placeholder, opens Payload media modal
   - **PayloadLexicalEditor.tsx**: Full Lexical integration for rich text
   - **InlineLexicalEditor.tsx** + **FormatToolbar.tsx**: Floating toolbar (bold, italic, link)

7. **Container Adapter Pattern** — All nesting logic abstracted:
   - `isContainer(block)`: Check if block supports children
   - `getContainerSchema(block)`: Returns 'layout' | 'content' | null
   - `getChildren(block)`: Get nested blocks array
   - `setChildren(block, children)`: Update children immutably
   - `getChildrenPath(block)`: Path array for deep updates
   - `findBlockById(blocks, id)`: Recursive search
   - `findParentContainer(blocks, childId)`: Find parent
   - Container schemas: Main (`layout.content.blocks`), Nested (`content.content.blocks`)

8. **Drag & Drop (dnd-kit)** — Implementation details:
   - PointerSensor configuration
   - pointerWithin collision detection (accurate for nested containers)
   - Cycle prevention: `isDescendantOf` check before allowing drops
   - Reordering within containers and across containers
   - DragOverlay for smooth visual feedback

9. **History & Undo/Redo** — HistoryContext implementation:
   - Deep clone using JSON.parse/stringify
   - Validation before recording and restoring
   - Text edit batching (1s debounce)
   - Cursor tracking for history-aware save state
   - Keyboard shortcuts: Cmd+Z (undo), Cmd+Shift+Z (redo)

10. **Save Strategy** — How changes persist:
    - No Payload form state binding (direct API approach)
    - PATCH to `/api/{collection}/{id}` with debounced queue (useSaveQueue hook)
    - Optimistic UI updates
    - Auto-save with configurable debounce
    - Why NOT form state: avoids re-render cascades, better performance for visual editing

11. **Keyboard Shortcuts** — Complete shortcut reference:
    - Cmd+Z: Undo, Cmd+Shift+Z: Redo
    - Cmd+D: Duplicate, Delete/Backspace: Delete
    - Cmd+Up/Down: Move block
    - Cmd+L: Toggle layers, Escape: Clear selection

12. **Responsive Preview** — Viewport preset system:
    - useViewportPreset hook
    - Preset sizes (desktop, tablet, mobile)
    - CSS containment for preview isolation

13. **CSS Architecture** — How plugin stays portable:
    - No direct CSS imports from consuming app
    - Plugin CSS variables (`--vb-*`) reference frontend tokens with fallbacks
    - `getCSSVar()`, `setCSSVar()` utilities
    - CSS containment (`contain: content`, `isolation: isolate`)

14. **Thin Wrapper Pattern** — How consuming apps mount the plugin:
    - App re-exports plugin component: `export { VisualBuilder as default } from '@eab/payload-visual-builder/client'`
    - Payload import map resolution
    - Customization/extension points

15. **Figma Parallels** — How visual builder concepts map to Figma:
    - Canvas ↔ Figma canvas
    - Block selection ↔ Figma node selection
    - Inspector ↔ Figma right panel
    - Layers panel ↔ Figma layers panel
    - Container nesting ↔ Figma Auto Layout frames
    - Inline editing ↔ Figma text editing
    - Drag-drop ↔ Figma drag-drop
    - This section informs the Figma importer design

16. **Cross-References** — Link to payload-blocks.md (block configs), payload-figma-mapping.md (mapping rules), figma-api-plugin.md (Figma plugin parallels), design-to-code-layout.md (Auto Layout → flex), css-strategy.md (CSS layers)

**Target: ~1000-1200 lines.**
  </action>
  <verify>
- File exists at knowledge/payload-visual-builder.md
- Contains all 16 sections listed above
- Component descriptions match actual reference project implementation
- Container adapter functions documented accurately
- Cross-references to at least 5 existing knowledge modules
- No secrets or API keys
  </verify>
  <done>payload-visual-builder.md exists with comprehensive visual builder architecture covering plugin pattern, components, inline editing, nesting, drag-drop, history, save strategy, and Figma parallels</done>
</task>

<task type="auto">
  <name>Task 2: Cross-verify Phase 5 modules and update CLAUDE.md</name>
  <files>knowledge/payload-blocks.md, knowledge/payload-figma-mapping.md, knowledge/payload-visual-builder.md, CLAUDE.md</files>
  <action>
**Cross-verification (follow Phase 2-4 pattern):**

1. Build a 3×3 cross-reference matrix for the 3 new PayloadCMS modules
2. Verify each module references the other two where relevant
3. Verify each new module references relevant existing modules (design-to-code-layout, css-strategy, design-tokens, etc.)
4. Verify existing modules that should reference new modules get updated:
   - css-strategy.md should reference payload-blocks.md (CSS Modules per block pattern)
   - design-tokens.md should reference payload-figma-mapping.md (token bridge to CMS)
   - design-to-code-semantic.md should reference payload-figma-mapping.md (HTML element → block mapping)
5. Fix any missing cross-references

**CLAUDE.md update:**

1. Read current CLAUDE.md
2. Remove "(coming)" from the 3 PayloadCMS module entries in the Knowledge Modules table
3. Update descriptions to match actual module content (follow pattern from Phase 2-4 updates)
4. Verify all 16 knowledge modules are listed (13 existing + 3 new)

**STATE.md update:**

1. Do NOT update STATE.md — execution workflow handles this
  </action>
  <verify>
- All 3 PayloadCMS modules cross-reference each other
- At least 3 existing modules updated with new cross-references
- CLAUDE.md shows 16 knowledge modules, 3 PayloadCMS modules without "(coming)"
- No broken cross-references
  </verify>
  <done>All Phase 5 modules cross-verified with bidirectional references, existing modules updated, CLAUDE.md reflects complete PayloadCMS knowledge suite. Phase 5 complete.</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] payload-visual-builder.md follows established module structure
- [ ] Cross-reference matrix complete (3×3 new + connections to existing)
- [ ] CLAUDE.md accurately lists all 16 knowledge modules
- [ ] No orphaned or broken cross-references
- [ ] No secrets, API keys, or credentials
</verification>

<success_criteria>

- All 3 PayloadCMS knowledge modules complete and cross-verified
- Visual builder documentation faithful to @eab/payload-visual-builder source
- Bidirectional cross-references between all related modules
- CLAUDE.md updated with Phase 5 modules
- Phase 5 complete — ready for Phase 6 (Plugin Development)
</success_criteria>

<output>
After completion, create `.planning/phases/05-payload-integration/05-02-SUMMARY.md`:

# Phase 5 Plan 2: Visual Builder & Verification Summary

**[Substantive one-liner]**

## Accomplishments
## Files Created/Modified
## Decisions Made
## Issues Encountered
## Next Step
Phase 5 complete, ready for Phase 6 (Plugin Development Module)
</output>
