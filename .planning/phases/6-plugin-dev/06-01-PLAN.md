---
phase: 6-plugin-dev
plan: 01
type: execute
---

<objective>
Create plugin architecture and codegen plugin knowledge modules documenting how to build, structure, and develop Figma plugins — covering the @create-figma-plugin toolchain, project structure patterns, IPC architecture, and codegen plugin development lifecycle.

Purpose: Phase 2 documented the Figma Plugin API reference (what types/methods exist). This plan documents *how to build production plugins* — project setup, architecture patterns, messaging design, and codegen-specific development. Sources: the production plugin codebase + existing API reference modules.
Output: `knowledge/plugin-architecture.md` and `knowledge/plugin-codegen.md`
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Direct dependencies (from frontmatter):
@.planning/phases/2-figma-api/02-02-SUMMARY.md

# Existing API reference modules (build on, don't duplicate):
@knowledge/figma-api-plugin.md
@knowledge/figma-api-devmode.md

# Source codebase for production patterns:
# Reference plugin source codebase
# Key source dirs: src/main.ts, src/ui.tsx, src/types/events.ts, src/extraction/, src/generation/, src/tokens/, src/export/
# Package: @create-figma-plugin v4.0.3, Preact UI, CodeMirror, document access: dynamic-page

# Archive specs (cross-reference for completeness):
@archive/agent-rewritten-01.md

**Tech stack available:** @create-figma-plugin, Preact, TypeScript, CodeMirror
**Established patterns:** Plugin sandbox model, IPC message pattern, codegen plugin pattern, dev resources API pattern
**Constraining decisions:**
- Phase 2: Standard plugins editorType ["figma"], codegen plugins editorType ["dev"]
- Phase 2: IPC patterns documented with correlation ID and network proxy patterns
- Phase 1: Module structure: title → purpose → when-to-use → content → cross-refs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plugin-architecture.md knowledge module</name>
  <files>knowledge/plugin-architecture.md</files>
  <action>
Create comprehensive plugin architecture knowledge module covering HOW to build Figma plugins (not API reference — that's in figma-api-plugin.md). Structure with standard module format (Purpose, When to Use, Content, Cross-References).

Content sections to include:

1. **Project Setup with @create-figma-plugin** — scaffolding, package.json configuration (figma-plugin section with id, name, main, ui, editorType, documentAccess, networkAccess), TypeScript config, build toolchain. Use the production plugin as reference: @create-figma-plugin v4.x with Preact UI.

2. **Project Structure Patterns** — organize by concern following the production plugin's proven layout:
   - `src/main.ts` — event-driven Figma backend (sandbox)
   - `src/ui.tsx` — Preact/React UI entry point
   - `src/types/` — shared type definitions (events, extracted data, generated output)
   - `src/extraction/` — design data extraction modules
   - `src/generation/` — code generation modules
   - `src/tokens/` — design token processing
   - `src/export/` — bundle and asset export
   - `src/components/` — UI components
   - `src/hooks/` — UI state hooks
   - `src/utils/` — shared utilities

3. **IPC Architecture** — deep dive into main↔UI communication:
   - Type-safe event system with typed handlers (on/emit from @create-figma-plugin/utilities)
   - Event naming conventions (VERB_NOUN: EXTRACT_FRAME, FRAME_EXTRACTED)
   - Request/response pairing (EXTRACT_FRAME → FRAME_EXTRACTED)
   - Progress events (EXTRACTION_PROGRESS for long operations)
   - Error propagation (structured ErrorData with code, message, details)
   - Async patterns (await in main thread, Promise wrappers in UI)

4. **Plugin Manifest Configuration** — detailed manifest.json patterns:
   - Standard plugin manifest (editorType: ["figma"])
   - Document access modes (dynamic-page for async node fetching)
   - Network access whitelist (for font loading, API calls from UI)
   - Plugin parameters and relaunch buttons

5. **UI Architecture** — building plugin UIs:
   - Preact vs React tradeoffs (bundle size in plugin context)
   - @create-figma-plugin/ui component library
   - Custom UI with HTML/CSS/JS
   - CodeMirror integration for code display
   - Live preview patterns (HTML rendering in iframe)
   - State management (useHistory for undo/redo)

6. **Data Flow Architecture** — the extraction → generation → export pipeline:
   - Stage 1: Extraction (Figma nodes → JSON-serializable schema)
   - Stage 2: Generation (extracted schema → element tree with styles)
   - Stage 3: Export (element tree → HTML/CSS/assets bundle)
   - Why JSON-serializable intermediate format (crosses IPC boundary)
   - ExtractedNode interface pattern (id, name, type, bounds, layout, fills, strokes, effects, text, asset, children)

Cross-reference figma-api-plugin.md for API details. Do NOT duplicate API method listings — reference them. Focus on architecture decisions, project organization, and development patterns.

Target: ~800-1000 lines following established module conventions.
  </action>
  <verify>
- File exists at knowledge/plugin-architecture.md
- Follows module structure: Purpose, When to Use, Content, Cross-References
- Contains @create-figma-plugin setup instructions
- Contains IPC architecture with type-safe events
- Contains data flow pipeline (extraction → generation → export)
- Cross-references figma-api-plugin.md, NOT duplicating API reference
- No real secrets or API keys
  </verify>
  <done>plugin-architecture.md created with project setup, structure patterns, IPC architecture, manifest config, UI architecture, and data flow pipeline — all sourced from production plugin patterns</done>
</task>

<task type="auto">
  <name>Task 2: Create plugin-codegen.md knowledge module</name>
  <files>knowledge/plugin-codegen.md</files>
  <action>
Create comprehensive codegen plugin knowledge module covering how to build Dev Mode codegen plugins that generate code from Figma designs. Structure with standard module format.

Content sections to include:

1. **Codegen Plugin Setup** — manifest configuration with editorType: ["dev"], capabilities: ["codegen"], build setup differences from standard plugins.

2. **Codegen Plugin Lifecycle** — the generate callback flow:
   - `figma.codegen.on('generate', handler)` registration
   - CodegenEvent properties (node, language)
   - CodegenResult format (title, code, language)
   - Returning multiple results (multi-language, multi-file)
   - Async generation patterns

3. **Preferences System** — user configuration in codegen plugins:
   - Unit preferences (px, rem, em)
   - Select preferences (framework selection, naming convention)
   - Action preferences (trigger-based operations)
   - Default values and persistence

4. **Code Generation Patterns** — practical patterns from the production plugin:
   - React/TSX generation (component structure, props, imports)
   - CSS generation (layered approach: layout + visual + typography)
   - Multi-language output (HTML, React, Vue, Svelte patterns)
   - Layout CSS from Auto Layout (reference design-to-code-layout.md patterns)
   - Component instance handling (when to generate vs reference)
   - Responsive code generation (multi-frame → media queries)
   - BEM class naming in generated code

5. **Code Quality in Generated Output** — ensuring clean output:
   - HTML validation (tag structure, bracket matching)
   - CSS validation (property syntax, bracket matching)
   - JavaScript/expression removal for safety
   - ValidationResult pattern with line/column errors
   - Code formatting and indentation

6. **Integration with Dev Resources** — linking generated code:
   - Creating dev resources from codegen plugins
   - Linking components to repositories
   - Node-to-code bidirectional references (data-figma-id)

7. **Standard vs Codegen Plugin Comparison** — decision guide:
   - When to build standard plugin vs codegen plugin
   - Combining both in one project
   - Shared code between plugin types

Cross-reference figma-api-devmode.md for API details and design-to-code-*.md modules for mapping rules. Focus on development patterns, not API reference.

Target: ~800-1000 lines following established module conventions.
  </action>
  <verify>
- File exists at knowledge/plugin-codegen.md
- Follows module structure: Purpose, When to Use, Content, Cross-References
- Contains codegen lifecycle (generate callback, CodegenResult)
- Contains preferences system documentation
- Contains code generation patterns from the production plugin
- Contains code quality/validation patterns
- Cross-references figma-api-devmode.md and design-to-code modules
- No real secrets or API keys
  </verify>
  <done>plugin-codegen.md created with codegen setup, lifecycle, preferences, code generation patterns, code quality, dev resources integration, and standard vs codegen comparison — sourced from production plugin patterns</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] Both knowledge modules exist in knowledge/ directory
- [ ] Both follow module structure convention (Purpose, When to Use, Content, Cross-References)
- [ ] plugin-architecture.md covers: setup, structure, IPC, manifest, UI, data flow
- [ ] plugin-codegen.md covers: lifecycle, preferences, generation patterns, quality, dev resources
- [ ] No duplication with existing figma-api-plugin.md or figma-api-devmode.md (reference, don't copy)
- [ ] No real secrets or API keys in any file
- [ ] Cross-references between new modules and existing modules are accurate
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No duplication with Phase 2 API reference modules
- Both modules sourced from production plugin patterns
- Cross-references valid across all knowledge modules
</success_criteria>

<output>
After completion, create `.planning/phases/6-plugin-dev/06-01-SUMMARY.md`
</output>
