---
phase: 7-skills-install
plan: 02
type: execute
---

<objective>
Create three specialized Claude Code skills: extract-tokens, map-payload-block, and audit-plugin.

Purpose: These skills serve specific workflows — design token extraction, CMS integration, and plugin quality auditing — consuming the specialized knowledge modules from Phases 4-6.
Output: Three skill files in `commands/figma/` ready for installation.
</objective>

<execution_context>
~/.claude/get-shit-done/workflows/execute-phase.md
./summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/7-skills-install/07-01-SUMMARY.md

# Knowledge modules these skills will @reference:
@knowledge/design-tokens.md
@knowledge/design-tokens-variables.md
@knowledge/figma-api-variables.md
@knowledge/css-strategy.md
@knowledge/payload-blocks.md
@knowledge/payload-figma-mapping.md
@knowledge/payload-visual-builder.md
@knowledge/plugin-architecture.md
@knowledge/plugin-codegen.md
@knowledge/plugin-best-practices.md
@knowledge/figma-api-plugin.md

# Conventions (same as plan 01):
@commands/figma/README.md

**Constraining decisions:**
- [Phase 2]: Token extraction priority: Variables API > styles > file traversal > Plugin API
- [Phase 2]: Variables API requires Enterprise org full member access
- [Phase 4]: Token threshold-based promotion to CSS custom properties
- [Phase 5]: Container max nesting: 2 levels
- [Phase 5]: Mapping uses multi-signal confidence scores
- [Phase 6]: 3-stage data flow pipeline: extraction → generation → export
- [Phase 6]: Codegen 3-second timeout strategy
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extract-tokens skill</name>
  <files>commands/figma/extract-tokens.md</files>
  <action>
Create the extract-tokens skill that extracts design tokens from Figma Variables/styles and generates CSS custom properties + Tailwind config. The skill should:

1. YAML frontmatter: name `figma-extract-tokens`, description for extracting design tokens from Figma files into CSS variables and Tailwind configuration.
2. Accept `$ARGUMENTS` as Figma file/node JSON data containing variables, styles, or color/typography values.
3. Reference knowledge modules:
   - `knowledge/design-tokens.md` (extraction pipeline, threshold promotion, naming)
   - `knowledge/design-tokens-variables.md` (Variables API resolution, modes, fallbacks)
   - `knowledge/figma-api-variables.md` (API specifics for variable collections)
   - `knowledge/css-strategy.md` (where tokens fit in three-layer architecture)
4. Process steps:
   - Identify token sources: Variables API collections (preferred), published styles, file traversal
   - For Variables: resolve bound variables through fallback chains, detect modes (light/dark/brand)
   - Categorize tokens: colors, typography, spacing, radii, shadows, breakpoints
   - Apply threshold-based promotion: if used N+ times → promote to CSS custom property
   - Generate HSL color naming convention
   - Generate spacing scale (4px base)
   - Render output formats:
     * CSS custom properties (`:root { --color-primary: hsl(...); }`)
     * SCSS variables (if requested)
     * Tailwind config extension (`theme.extend.colors`, etc.)
   - Handle mode-aware rendering (CSS `@media (prefers-color-scheme)` or `.theme-dark` class)
5. Output format: tokens.css file + tailwind.config.ts extension snippet.

Key rules:
- Variables API is preferred source but requires Enterprise org access — document fallback path
- HSL format for colors (enables easy manipulation)
- Spacing always multiples of 4px base unit
- Token names follow `--{category}-{name}-{variant}` convention
  </action>
  <verify>File exists at commands/figma/extract-tokens.md with frontmatter and token extraction process</verify>
  <done>Skill references tokens + variables knowledge modules, handles Variable API + fallback paths, outputs CSS vars + Tailwind config</done>
</task>

<task type="auto">
  <name>Task 2: Create map-payload-block skill</name>
  <files>commands/figma/map-payload-block.md</files>
  <action>
Create the map-payload-block skill that maps a Figma component to a PayloadCMS block configuration + renderer + types. The skill should:

1. YAML frontmatter: name `figma-map-payload-block`, description for converting Figma components into PayloadCMS block definitions.
2. Accept `$ARGUMENTS` as Figma component JSON data or component description.
3. Reference knowledge modules:
   - `knowledge/payload-blocks.md` (block system, field types, factories)
   - `knowledge/payload-figma-mapping.md` (mapping decision tree, confidence scores)
   - `knowledge/payload-visual-builder.md` (visual builder integration patterns)
   - `knowledge/css-strategy.md` (CSS approach for block renderers)
4. Process steps:
   - Analyze Figma component structure (properties, variants, children, instances)
   - Apply multi-signal confidence scoring: frame name + structure + dimensions + content
   - Match to block type from 18-type catalog (Hero, Container, Card, Button, RichText, etc.)
   - Map component properties → block fields:
     * Text layers → text/richText fields
     * Boolean variants → checkbox fields
     * Enum variants → select fields
     * Instance swaps → relationship/block fields
     * Color properties → tokens (not hardcoded)
   - Map variants → CVA (class-variance-authority) configuration
   - Generate container nesting rules (max 2 levels: Container > NestedContainer)
   - Generate block config (PayloadCMS `Block` type definition)
   - Generate React renderer component
   - Generate TypeScript types
   - Generate tokens.css consumption pattern (CSS Modules + custom properties)
5. Output format: block config .ts + renderer .tsx + .module.css + types.

Key rules:
- Container nesting max 2 levels
- Lexical editor restricted per block type
- Block settings stored as Tailwind utility class strings (Layer 1)
- Use field factories for common patterns (don't duplicate field definitions)
  </action>
  <verify>File exists at commands/figma/map-payload-block.md with mapping process and PayloadCMS output format</verify>
  <done>Skill references PayloadCMS knowledge modules, uses confidence scoring for block type matching, outputs complete block definition (config + renderer + types + CSS)</done>
</task>

<task type="auto">
  <name>Task 3: Create audit-plugin skill</name>
  <files>commands/figma/audit-plugin.md</files>
  <action>
Create the audit-plugin skill that audits Figma plugin code against production best practices from the reference plugin. The skill should:

1. YAML frontmatter: name `figma-audit-plugin`, description for auditing Figma plugin code quality and patterns.
2. Accept `$ARGUMENTS` as file paths to plugin source code, or a description of the plugin to audit.
3. Reference knowledge modules:
   - `knowledge/plugin-architecture.md` (sandbox model, IPC, data flow pipeline)
   - `knowledge/plugin-codegen.md` (codegen plugin patterns if applicable)
   - `knowledge/plugin-best-practices.md` (7-section production checklist)
   - `knowledge/figma-api-plugin.md` (Plugin API reference)
4. Process steps:
   - Read plugin source files (manifest, main code, UI code)
   - Audit against 7 best practice sections:
     1. Error handling: try/catch in message handlers, figma.notify for user feedback, graceful degradation
     2. Performance: batch API reads, avoid traversing entire document, use findAll with criteria
     3. Memory management: cleanup event listeners, avoid large object retention, chunk large exports
     4. Caching: cache node lookups within operations, invalidate on selection change
     5. Async patterns: proper IPC message/response correlation, timeout handling
     6. Testing: unit test extraction/generation logic separately from plugin API
     7. Distribution: manifest correctness, permissions scoping, update strategy
   - For codegen plugins specifically: check 3-second timeout compliance, progressive complexity, Dev Mode patterns
   - Check IPC patterns: type-safe message definitions, correlation IDs, error propagation
   - Check data flow: extraction → generation → export pipeline separation
   - Rate each section: pass/warn/fail with specific code references
5. Output format: Audit report with sections, ratings, specific findings, and recommended fixes.

The skill should read the actual source files provided and give concrete, actionable feedback — not generic advice.
  </action>
  <verify>File exists at commands/figma/audit-plugin.md with audit checklist and reporting format</verify>
  <done>Skill references plugin knowledge modules, audits against 7 best practice sections, provides actionable findings with code references</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All three skill files exist in commands/figma/
- [ ] Each has valid YAML frontmatter (name, description)
- [ ] Each @references appropriate specialized knowledge modules
- [ ] Each has clear process steps and output format
- [ ] extract-tokens handles Variables API + fallback paths
- [ ] map-payload-block uses confidence scoring and outputs complete block definition
- [ ] audit-plugin covers all 7 best practice sections
</verification>

<success_criteria>
- Three skill files created: extract-tokens.md, map-payload-block.md, audit-plugin.md
- Each follows Claude Code SKILL.md conventions
- Each references relevant knowledge modules by path
- Each has: objective, input, process, output sections
- Skills provide specialized workflows consuming Phase 4-6 knowledge
</success_criteria>

<output>
After completion, create `.planning/phases/7-skills-install/07-02-SUMMARY.md`
</output>
